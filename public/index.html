<html>
<script type="text/javascript" src="js/d3.min.js"></script>
<script src="https://code.jquery.com/jquery-2.2.4.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>


<body>

	
		<button type="button" id="button">5min</button>
		<button type="button" id="button2">1min</button>
	
	<script>
		var webSocket = new WebSocket("ws://localhost:3000");
		
			webSocket.onopen = function (event) {
			console.log('Websocket connection open'); //when the connection is established log this message to the console
		};

		webSocket.onclose = function () {
			console.log("closed")
		}

		webSocket.onmessage = function (event, err) {
			var e = JSON.parse(event.data); //the data will be retrieved as a JSON string this will parse the data out of that string
			var data = e;
			if (data !== null && typeof data === 'object') //if the data recieved is not null and is of type object
			{
                if(data.Tag =="One Minute"){
				pastRectangles.push(data); //push this to the pastRectangle array, this will be used to draw historical data
				//pastDraw();
                }else{
                    fiveArray.push(data)
                }
			} else {
				oneMinuteArray.push(data);
				bardata.push(data); //this array will containt the current price every second
			}
		}

		webSocket.close = function (event) {
			console.log("connection closed");
		}

		
		
		
		var width = 600;
		var height = 500;
		var marginTop = 20;
		var marginBottom = 20;
		var marginLeft = 60; //initial space required to the left of the chart 
		var marginRight = 20;
		var candleWidth = 20;
		var candleGap = 40;
		var candleMargin = 10;
		var wickThickness = "2";
		var hLineColor = "#b5b6b7";
		var barWidth = 50;
		var barOffset = 55;
		var fiveArray = [{
                Date: 01 / 12 / 15,
                High: 15,
                Low: 15,
                Open: 15,
                Close: 15
            }];
		var pastRectangles = [{
               Date: 01 / 12 / 15,
                High: 15,
                Low: 15,
                Open: 15,
                Close: 15
            }];
                
		var bardata = []; //array that holds the current value for the candlestick chart
		var oneMinuteArray = []; //this array will hold data to draw candlesticks at 1 minute
		var maxi = d3.max(pastRectangles, function (d)
		{
		return d.High;
		}); // to check what the max value in the data array is ... for info purposes

		var maxLow = d3.min(pastRectangles.map(function (x)
		{
		return x["Low"];
		})) 
		var maxHigh = d3.max(pastRectangles.map(function (x)
		{
		return x["High"];
		})) 
		
		var maxMinDiff = (maxHigh - maxLow) * 0.1;
		console.log(maxMinDiff);

		function min(a, b)
		{
		return a < b ? a : b;
		};
		
		//function that will return the highest of two number a or b
		function max(a, b)
		{
		return a > b ? a : b;
		};
		
		var x = d3.scale.linear().domain([-width / 2, width / 2]).range([0, width]);

		//Var Y is a function that will scale the numbers on the Y axis from an input domain into output range; height-0 which inverts or flips Y otherwise visualisation is upside down
		var y = d3.scale.linear()
				.domain([maxLow - maxMinDiff, maxHigh + maxMinDiff]) //changed to reflect new variables for lowest, highest and difference to define input  domain
				.range([height - marginTop - marginBottom, 0 + marginLeft + marginRight]); //range has still not been modified ... remember x,y have been reversed to reflect y,x


			var svg = d3.select('body')
			.append('svg')
			.attr('width', width)
			.attr('height', height)
			.style('background', 'black')
			.append("g")
			.attr("class", "rectangles")

//		update(pastRectangles[pastRectangles.length - 1]); //make sure the updating bar is set after the last index in the pastRectangles array
		
			pastDraw(fiveArray);

	function pastDraw(array) {
			var pastRect = 	svg.selectAll('rect').data(array); //This function will loop through the pastRectangles array and will
						   	pastRect.enter() //draw a rectange for every index in the array
							.append("rect") //The reason for not using bardata is that it only holds one value
							.attr("g", "rectangles")
							.attr("x", function (d, i) {
								return candleMargin + marginLeft + (candleGap * i);
							}) //every second and therefore a second array is needed to hold the
							.attr("y", function (d, i) {
								return candleMargin + marginLeft + (candleGap * i);
							}) //historical data
							.attr("height", function (d) 
							{
								return y(min(d.Open, d.Close)) - y(max(d.Open, d.Close))
							})
							.attr("width", candleWidth)
							.attr("id", "history")
							.attr("fill", function(d)
							{
							  return d.Open > d.Close ? "#a01f1b" : "#1ba048";
							});
							pastRect.transition()
							.duration(1000)
							.ease('linear')
							.attr("height", function (d)
							{
								return y(min(d.Open, d.Close)) - y(max(d.Open, d.Close))
							});
							pastRect.exit();
		}
				
					document.getElementById("button2").addEventListener("click", function(){
						pastDraw(pastRectangles)
						console.log("clicked one Minute Button")
					})
					document.getElementById("button").addEventListener("click", function(){
						d3.selectAll("rect").remove();
						pastDraw(fiveArray)
						console.log("clicked Five Minute Button")
					})


//		function update(bardata) {
//				var rect = svg.selectAll('rect').data([bardata]);							//This function essentially draws a new rectangle for every 
//				rect.enter()																//value of bardata, however, because bardata is constantly 
//				.append("rect")																//removing the current value for a new value every second
//				.attr("x",offset) 															//it gives the illusion of one rectangle updating regularly
//				.attr("y", function(d){return 500 - d})
//				.attr("id", "updateBar")
//				.attr("height", bardata)										
//				.attr("width", 60)
//				.attr("fill", "white")
//				.attr("stroke", "black")
//				rect.transition()
//				.duration(1000)
//				.ease('linear')
//				.attr("height", function (d) {
//					return d
//				})
//			
//			
//				rect.exit();
//			
//		}
		

//		setInterval(function () {
//			update(bardata); //call the update method everysecond with the latest price
//			bardata.shift(); //remove the first index of the array, used to insure array only ever has one value
//		}, 1000)
	</script>


</body>

</html>