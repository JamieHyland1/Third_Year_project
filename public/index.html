<html>
<script type="text/javascript" src="js/d3.min.js"></script>
<script src="https://code.jquery.com/jquery-2.2.4.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>


<body>

	<script>
		var webSocket = new WebSocket("ws://localhost:3000");
		var pastRectangles = [];
		var bardata = []; //array that holds the current value for the candlestick chart
		var oneMinuteArray = []; //this array will hold data to draw candlesticks at 1 minute
		
		 var marginTop = 20;
            var marginBottom = 20;
            var marginLeft = 60; //initial space required to the left of the chart
            var marginRight = 20;

            var candleWidth = 20;
            var candleGap = 40;
            var candleMargin = 10;

            var wickThickness = "2";

            var hLineColor = "#b5b6b7";


		webSocket.onopen = function (event) {
			console.log('Websocket connection open'); //when the connection is established log this message to the console
		};

		webSocket.onclose = function () {
			console.log("closed")
		}

		webSocket.onmessage = function (event) {
			var e = JSON.parse(event.data); //the data will be retrieved as a JSON string this will parse the data out of that string
			var data = e;
			if (data !== null && typeof data === 'object') //if the data recieved is not null and is of type object
			{
				pastRectangles.push(data); //push this to the pastRectangle array, this will be used to draw historical data
			} else {
				oneMinuteArray.push(data);
				bardata.push(data); //this array will containt the current price every second
				//console.log(e)
			}
		}

		webSocket.close = function (event) {
			console.log("connection closed");
		}

		 	  var maxi = d3.max(pastRectangles, function(d) {
                return d.high;
            }); // to check what the max value in the data array is ... for info purposes
            console.log(maxi); //not displaying in brackets??

            // .map() creates an new array based on function
            var maxLow = d3.min(pastRectangles.map(function(x) {
                    return x["low"];
                })) // returns the lowest value of 'low'
            var maxHigh = d3.max(pastRectangles.map(function(x) {
                    return x["high"];
                })) // returns the highest value of 'high'
            var maxMinDiff = (maxHigh - maxLow) * 0.1;
            console.log(maxMinDiff);

            console.log(maxi); //not displaying in brackets??

            // .map() creates an new array based on function
            var maxLow = d3.min(pastRectangles.map(function(x) {
                    return x["low"];
                })) // returns the lowest value of 'low'
            var maxHigh = d3.max(pastRectangles.map(function(x) {
                    return x["high"];
                })) // returns the highest value of 'high'
            var maxMinDiff = (maxHigh - maxLow) * 0.1;
            console.log(maxMinDiff);


		var height = window.innerHeight
			, width = window.innerWidth
			, barWidth = 50
			, barOffset = 5;
				var offset = pastRectangles.length * (barOffset + barWidth);
		var move = 1;

		
		var scale = d3.scale.linear()
			.range([0, height])
			.domain([0, height]);

		var y = d3.scale.linear()
                .domain([maxLow - maxMinDiff, maxHigh + maxMinDiff]) //changed to reflect new variables for lowest, highest and difference to define input domain
                .range([height - marginTop - marginBottom, 0 + marginLeft + marginRight]); //range has still not been modified ... remember x,y have been reversed to reflect y,x
		

		var svg = d3.select('body')
			.append('svg')
			.attr('width', width)
			.attr('height', height)
			.style('background', '#C9D7D6')
			.append("g")
			.attr("class", "rectangles")

		update(pastRectangles[pastRectangles.length - 1]); //make sure the updating bar is set after the last index in the pastRectangles array
		pastDraw();


		function pastDraw() {
			var pastRect = svg.selectAll('rect').data(pastRectangles); //This function will loop through the 			                                                                                pastRectangles array and will
			pastRect.enter() //draw a rectange for every index in the array
				.append("rect") //The reason for not using bardata is that it only holds one value
				.attr("g", "rectangles")
				.attr("x", function (d, i) {
					return i * (barWidth + barOffset)
				}) //every second and therefore a second array is needed to hold the
				.attr("y", function (d) {
					return height - d.close
				}) //historical data
				.attr("height", function (d) {
					return d.high
				})
				.attr("width", 60)
				.attr("id", "history")
				.attr("fill", "steelblue")
			pastRect.transition()
				.duration(1000)
				.ease('linear')
				.attr("height", function (d) {
					return d.high
				})
			pastRect.exit()
			var bar = svg.selectAll("#updateBar")
				.transition()
				.duration(1000)
				.attr("transform", "translate(" + move + ",0)")
			move += (barWidth + barOffset);

			setTimeout(function () {
				pastRectangles.push(bardata)
				pastDraw();
			}, 10000)


		}


		function update(bardata) {
				var rect = svg.selectAll('rect').data([bardata]);							//This function essentially draws a new rectangle for every 
				rect.enter()																//value of bardata, however, because bardata is constantly 
				.append("rect")																//removing the current value for a new value every second
				.attr("x",offset) 															//it gives the illusion of one rectangle updating regularly
				.attr("y", function(d){return 500 - d})
				.attr("id", "updateBar")
				.attr("height", bardata)										
				.attr("width", 60)
				.attr("fill", "white")
				.attr("stroke", "black")
				rect.transition()
				.duration(1000)
				.ease('linear')
				.attr("height", function (d) {
					return d
				})
			
			
				rect.exit();
			
		}
		

		setInterval(function () {
			update(bardata); //call the update method everysecond with the latest price
			bardata.shift(); //remove the first index of the array, used to insure array only ever has one value
		}, 1000)
	</script>
	<div class="message">

	</div>



</body>

</html>